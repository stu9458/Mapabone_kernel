From 1625f27894e9e28b5c222ad4fcf7483055556deb Mon Sep 17 00:00:00 2001
From: Ravi Babu <ravibabu@ti.com>
Date: Wed, 29 May 2013 18:37:03 +0530
Subject: [PATCH 3/3] usb: musb: dsps: handle babble condition for dsps
 platform

Adding babble_recovery operation as part of musb->ops, used
to recover from babble condition during babble interrupt.

Signed-off-by: Ravi Babu <ravibabu@ti.com>
---
 drivers/usb/musb/musb_dsps.c | 34 +++++++++++++++++++++++++++++++++-
 1 file changed, 33 insertions(+), 1 deletion(-)

diff --git a/drivers/usb/musb/musb_dsps.c b/drivers/usb/musb/musb_dsps.c
index e2fd263..b5aa3bc 100644
--- a/drivers/usb/musb/musb_dsps.c
+++ b/drivers/usb/musb/musb_dsps.c
@@ -329,9 +329,17 @@ static irqreturn_t dsps_interrupt(int irq, void *hci)
 	 * value but DEVCTL.BDEVICE is invalid without DEVCTL.SESSION set.
 	 * Also, DRVVBUS pulses for SRP (but not at 5V) ...
 	 */
-	if (is_host_active(musb) && usbintr & MUSB_INTR_BABBLE)
+	if (is_host_active(musb) && usbintr & MUSB_INTR_BABBLE) {
 		pr_info("CAUTION: musb: Babble Interrupt Occurred\n");
 
+		/* during babble condition the musb controller removes
+		 * session (or stops) and no longer in host mode. Hence
+		 * all the devices connected to root hub gets disconnected
+		 */
+		musb->int_usb = MUSB_INTR_BABBLE | MUSB_INTR_DISCONNECT;
+		musb->int_tx = musb->int_rx = 0;
+	}
+
 	if (usbintr & ((1 << wrp->drvvbus) << wrp->usb_shift)) {
 		int drvvbus = dsps_readl(reg_base, wrp->status);
 		void __iomem *mregs = musb->mregs;
@@ -524,6 +532,29 @@ static int dsps_musb_set_mode(struct musb *musb, u8 mode)
 	return 0;
 }
 
+static void dsps_musb_restart(struct musb *musb)
+{
+	struct device *dev = musb->controller;
+	struct dsps_glue *glue = dev_get_drvdata(dev->parent);
+	const struct dsps_musb_wrapper *wrp = glue->wrp;
+	void __iomem *reg_base = musb->ctrl_base;
+
+	/* Reset the musb */
+	dsps_writel(reg_base, wrp->control, (1 << wrp->reset));
+	udelay(100);
+
+	/* Stop the on-chip PHY and its PLL. */
+	usb_phy_vbus_off(musb->xceiv);
+	udelay(100);
+
+	/* Start the on-chip PHY and its PLL. */
+	usb_phy_vbus_on(musb->xceiv);
+	udelay(100);
+
+	/* reinit the endpoint fifo table and restart musb */
+	musb_restart(musb);
+}
+
 static struct musb_platform_ops dsps_ops = {
 	.init		= dsps_musb_init,
 	.exit		= dsps_musb_exit,
@@ -533,6 +564,7 @@ static struct musb_platform_ops dsps_ops = {
 
 	.try_idle	= dsps_musb_try_idle,
 	.set_mode	= dsps_musb_set_mode,
+	.babble_recovery = dsps_musb_restart,
 };
 
 static u64 musb_dmamask = DMA_BIT_MASK(32);
-- 
2.1.0.rc1

